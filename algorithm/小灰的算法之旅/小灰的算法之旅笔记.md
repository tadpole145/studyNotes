---
title: 小灰灰算法之旅笔记
date: 2021-01-15 13:10:24
author: 小蝌蚪
img: 
coverImg: 
top: false
cover: false
toc: true
mathjax: false
summary: 介绍yaml语法与详细使用
tags: [算法]
categories: [基础知识]
comments: false
---





>来源书籍: 小灰的算法之旅
>
>语言: Java



### 数据结构与算法

#### 基础概念

##### 数据结构

> 数据结构是数据的组织、管理和存储格式包括以下常见的结构

- 线性结构
- 树
- 图
- 其它数据结构

##### 算法

>
>算法是一系列程序指令，用于处理特定的运算和逻辑问题。衡量算法优劣的主要标准是时间复杂度和空间复杂度。

###### 时间复杂度

> 若存在函数f(n)，使得当n趋近于无穷大时，T(n)/f(n)的极限值为不等于零的常数，则称f(n)是T(n)的同数量级函数。记作T(n)=O(f(n))，称为O(f(n))，O为算法的渐进时间复杂度，简称为时间复杂度。只保留最高阶项,常数记为1.
>
> 大白话: 程序执行的时间成本

###### 空间复杂度

> 程序占用的空间大小



#### 线性数据结构

##### 数组

> 有限个相同类型的变量所组成的有序集合,每个变量被称作为元素.

###### 常用操作

- 增: 随机插入(O(n)),尾部插入(O(1)),越界插入(先扩容,再插入,时间复杂度O(n));

- 删:  随机删除(O(n)),尾部删除(O(1))
- 改: 时间复杂度O(1);
- 查: 时间复杂度O(1);

###### 优缺点

快速查找,但是写入慢.

##### 链表

###### 概念

在物理上非连续、非顺序的数据结构，由若干节点（node）所组成。

###### 单向链表

每一个节点又包含两部分，一部分是存放数据的变量data，另一部分是指向下一个节点的指针next

###### 双向链表

每一个节点除了拥有data和next指针，还拥有指向前置节点的prev 指针

###### 常用操作

- 增: 时间复杂度O(1),
- 删: 时间复杂度O(1),
- 改: 不考虑查找时间,单纯更新,时间复杂度O(1)
- 查 : 从第一个节点的指针开始遍历下一个节点,直到找到所需要的元素. 时间复杂度O(n)

##### 栈(stack)

一种线性数据结构; 先入后出  （First   In   Last   Out，简称FILO）,既可以用数组来实现，也可以用链表来实现.

###### 常见操作

- 入栈 : 增加一个元素
- 出栈 : 将栈顶元素弹出

###### 应用

- 回溯方法的调用链。比如递归调用

- 面包屑导航, 返回上一级页面

##### 队列(queue)

一种先入先出 （First   InFirst  Out，简称FIFO ）的线性数据结构,出口叫头,入口叫尾(rear). 与栈类似，队列这种数据结构既可以用数组来实现，也可以用链表来实现。

###### 常见操作

- 入队: 是把新元素放入队尾的位置，新元素的下一个位置将会成为新的队尾。

- 出队 : 将队头的元素移出,其下一个元素将成为新的队头.

###### 队列的实现

定容数组通过循环实现.  队尾指针指向的位置永远空出1位，所以队列最大容量比数组长度小1。

判断队列是否已满:

- 一种是另设一个布尔变量来判断；
- 第二种是少用一个元素空间，入队时先测试（(rear+1)%size = front）来测试满了还是还有空间；
- 第三种就是用一个计数器记录队列中的元素的总数。

![image-20210419144504569](https://raw.githubusercontent.com/tadpole145/images/main/image-20210419144504569.png)

###### 应用

- 多线程中，争夺公平锁的等待队列
- 网络爬虫实现网站抓取时，也是把待抓取的网站URL存入队列中

##### 双端队列( Double-ended queue，简称为Deque)

前端与后端都支持插入和删除操作的队列. 

![image-20210419152101714](https://raw.githubusercontent.com/tadpole145/images/main/image-20210419152101714.png)

###### 应用

存储一系列的撤销操作

##### 优先队列

谁的优先级最高，谁先出队。基于于二叉堆来实现.

##### 散列表(哈希表 )

通过key--value键值对来存储查找元素. 其本质也是一个数组,只是通过哈希函数,将Key和数组下标进行转换.不同的语言中,哈希函数的实现是不一样的.每一个对象都有属于自己的hashcode，这个hashcode是区分不同对象的重要标识。无论对象自身的类型是什么，它们的hashcode都是一个整型变量。

###### 什么是hash

Hash（哈希），又称“散列”。散列（hash）英文原意是“混杂”、“拼凑”、“重新表述”的意思。在某种程度上，散列是与排序相反的一种操作，排序是将集合中的元素按照某种方式比如字典顺序排列在一起，而散列通过计算哈希值，打破元素之间原有的关系，使集合中的元素按照散列函数的分类进行排列。 散列表可以说是数组和链表的结合

 hashCode() 表示的是对当前对象的唯一标示。计算 hashCode 的过程就称作 哈希。

###### 为什么要有 Hash

我们通常使用数组或者链表来存储元素，一旦存储的内容数量特别多，需要占用很大的空间，而且在**查找某个元素**是否存在的过程中，数组和链表都需要挨个循环比较，而通过 哈希 计算，可以大大**减少比较次数**。

###### 哈希函数

一种映射关系，根据数据的关键词 key ，通过一定的函数关系，计算出该元素存储位置的函数

###### 常见的哈希函数构造方法

- 直接定址法

取关键字或关键字的某个线性函数值为散列地址。即 H(key) = key 或 H(key) = a*key + b，其中a和b为常数

- 除留余数法

取关键字被某个不大于散列表长度 m 的数 p 求余，得到的作为散列地址。即 H(key) = key % p, p < m。 

- 数字分析法

当关键字的位数大于地址的位数，对关键字的各位分布进行分析，选出分布均匀的任意几位作为散列地址。仅适用于所有关键字都已知的情况下，根据实际应用确定要选取的部分，尽量避免发生冲突。

- 平方取中法

先计算出关键字值的平方，然后取平方值中间几位作为散列地址。随机分布的关键字，得到的散列地址也是随机分布的。

- 折叠法（叠加法）

将关键字分为位数相同的几部分，然后取这几部分的叠加和（舍去进位）作为散列地址。用于关键字位数较多，并且关键字中每一位上数字分布大致均匀。

- 随机数法

选择一个随机函数，把关键字的随机函数值作为它的哈希值。

###### 哈希冲突的解决

- 链接法（拉链法）

将所有关键字为同义词的结点链接在同一个单链表中。

- ==开放定址法==

使用某种探查(亦称探测)技术在散列表中寻找下一个空的散列地址，只要散列表足够大，空的散列地址总能找到。在Java中，ThreadLocal所使用的就是开放寻址法。

- ==链表法== (java中的hashMap使用此法)

HashMap数组的每一个元素不仅是一个Entry对象，还是一个链表的头节点。每一个Entry对象通过next指针指向它的下一个Entry节点。当新来的Entry映射到与之冲突的数组位置时，只需要插入到对应的链表中即可。

当经过多次元素插入，散列表达到一定饱和度时，Key映射位置发生冲突的概率会逐渐提高。大量元素拥挤在相同的数组下标位置，形成很长的链表，对后续插入操作和查询操作的性能都有很大影响。这时就需要对散列表进行扩容.

对HashMap来说,影响扩容的影子有2个:

- Capacity ，即HashMap的当前长度
- LoadFactor ，即HashMap的负载因子，默认值为0.75f

###### 如今扩容?

- 创建一个新的Entry空数组，长度是原数组的2倍。
- 重新Hash. 遍历原Entry数组，把所有的Entry重新Hash到新数组中。为什么要重新Hash呢？因为长度扩大以后，Hash的规则也随之改变。

JDK    8和以前的版本有着很大的不同。当多个Entry被Hash到同一个数组下标位置时，为了提升插入和查找的效率，HashMap会把Entry的链表转化为红黑树这种数据结构。



###### 哈希的应用

- 哈希表
- 分布式缓存



#### 树

##### 定义

树（tree）是n（n≥0）个节点的有限集。当n=0时，称为空树。

根节点: 没有父节点的节点

叶子节点: 没有孩子的节点

树的高度/深度: 树的最大层级数

##### 二叉树

树的一种特殊形式,每个节点最多有2个孩子节点.

**满二叉树**: 所有非叶子节点都存在左右孩子，并且所有叶子节点都在同一层级上，那么这个树就是满二叉树。![image-20210420170501412](https://raw.githubusercontent.com/tadpole145/images/main/image-20210420170501412.png)

**完全二叉树**:  一棵深度为k的有n个结点的二叉树，对树中的结点按从上至下、从左到右的顺序进行编号，如果编号为i（1≤i≤n）的结点与满二叉树中编号为i的结点在二叉树中的位置相同，则这棵二叉树称为完全二叉树

![image-20210420171721108](https://raw.githubusercontent.com/tadpole145/images/main/image-20210420171721108.png)

###### 二叉树的表达

其属于逻辑结构,即可用数组来表达,也可以使用链表来表达.

###### 应用

- 进行查找操作

- 维持相对顺序

**二叉查找树(二叉排序树):** 

- 如果左子树不为空，则左子树上所有节点的值均小于根节点的值
- 如果右子树不为空，则右子树上所有节点的值均大于根节点的值
- 左、右子树也都是二叉查找树

对于一个节点分布相对均衡  的二叉查找树来说，如果节点总数是n，那么搜索节点的时间复杂度就是O(logn) ，和树的深度是一样的。它和二分查找算法非常相似。

##### 二叉树的遍历

遍历本身是一个线性操作。但是二叉树是非线性结构,以不同的方式遍历,遍历顺序也不一样.一般分为以下几种:

- 深度优先遍历
  - 前序遍历。
  - 中序遍历。
  - 后序遍历。
- 广度优先遍历
  - 层序遍历。

###### 前序遍历--- 中左右

从根节点开始遍历,再到左孩子,接着到左孩子的左孩子,如果没有就遍历右孩子,再返回上一层级先左后右依次遍历.

###### 中序遍历--- 左中右

输出顺序是左子树、根节点、右子树;  首先访问根节点的左孩子，如果这个左孩子还拥有左孩子，则继续深入访问下去，一直找到不再有左孩子的节点，并输出该节点。

![image-20210421091054369](https://raw.githubusercontent.com/tadpole145/images/main/image-20210421091054369.png)

###### 后续遍历---左右中

二叉树的后序遍历，输出顺序是左子树、右子树、根节点。先左右孩子后父亲

![image-20210421092234719](https://raw.githubusercontent.com/tadpole145/images/main/image-20210421092234719.png)

这3种遍历方式的==区别==，仅仅是==根节点输出的执行位置不同==：前序遍历的输出在前，中序遍历的输出在中间，后序遍历的输出在最后。

###### 遍历实现方式

- 递归方法

- 栈

###### 广度优先遍历方式---队列

从根节点开始,先入队,后出队, 左孩子右孩子接着入队,如此循环直到结束.

##### 二叉堆

本质上是一种完全二叉树,分为

- 最大堆: 最大堆的任何一个父节点的值，都大于或等于它左、右孩子节点的值。堆顶是整个堆中的最大元素
- 最小堆: 最小堆的任何一个父节点的值，都小于或等于它左、右孩子节点的值。堆顶是整个堆中的最小元素 。

###### 二叉堆的构建

- 二叉堆插入节点: 将不符合的新节点与其父节点交换位置,直到符合为止.
- 二叉堆删除节点: 使用完全二叉树最底下的一个叶子节点替代被删除的节点,然后与其左右孩子进行比较后交换位置,直到符合要求为止.
- 非二叉堆构建二叉堆:  首先，从最后一个非叶子节点开始,与其左右孩子交换位置,逐层从右到左的进行动态交换,直到整棵树符合要求.

###### 二叉堆的代码实现

二叉堆虽然是一个完全二叉树，但它的存储方式并不是链式存储，而是顺序存储。二叉堆的所有节点都存储在数组中。

假设父节点的下标是parent，那么它的左孩子下标就是 2×parent+1 ；右孩子下标就是2×parent+2 。

###### 应用

 二叉堆是实现堆排序  及优先队列的基础。

##### 优先队列

- 最大优先队列:  无论入队顺序如何，都是当前最大的元素优先出队
- 最小优先队列，无论入队顺序如何，都是当前最小的元素优先出队

#### 排序

###### 分类

 **按时间复杂度划分**

- 时间复杂度O(n^2  )的排序算法
  - 冒泡排序
  - 选择排序
  - 插入排序
  - 希尔排序

- 时间复杂度O(nlogn)的排序算法

  - 快速排序
  - 归并排序
  - 堆排序

- 时间复杂度为线性的排序算法

  - 计数排序
  - 桶排序
  - 基数排序

  

**按稳定性划分**

稳定排序: 排序前后,顺序保持不变.

##### 冒泡排序

思想:循环遍历比较相邻元素,大的右移, 排序后相同的值顺序不变,属于稳定排序.

###### 冒泡排序的优化

- 设置是否有序的flag,如果有序了,则直接跳出循环,遍历结束.
- 记录最后一次元素交换的位置,即为无序数列的边界,后面就是有序数列,无需排序.

##### 鸡尾酒排序

思路: 第一轮从左到右,第二轮从右到左,如此循环直到有序,代码外层的大循环控制着所有排序回合，大循环内包含2个小循环，第1个小循环从左向右比较并交换元素，第2个小循环从右向左比较并交换元素。

- 优点: 能够在特定条件下，减少排序的回合数；
- 缺点: 代码量几乎增加了1倍。

它能发挥出优势的场景，是大部分元素已经有序的情况。

##### 快速排序

###### 思想

在每一轮挑选一个基准元素，并让其他比它大的元素移动到数列一边，比它小的元素移动到数列的另一边，从而把数列拆解成两个部分。

###### 基准元素的选取

- 选择第一个元素
- 随机选一个元素, 和第一个元素交换位置

###### 元素交换

- 双边循环法

> 设置left和right 2个指针,指向数列的最左和最右2个元素,第一次循环,从right指针开始,如果≥基准元素pivot,则指针向左移动一位直到条件不满足,否则停止移动,切换到left指针, 如果left≤pivot,则右移一位,否则停止移动.这时,让左右指针的元素交换.然后右指针左移一位,左指针右移一位,接着进入第二轮的循环重复第一轮步骤.直到左右指针重合,然后交换重合指针的元素与基准元素的位置,使之成为新的基准元素.
>
> 实现方式: 递归

- 单边循环法

> 选定第一个作为基准元素, 同时设置第一个元素为mark指针,它代表小于基准元素的区域边界.然后开始遍历,如果＞pivot,则继续遍历,如果＜pivot,则mark指针右移一位,然后让新遍历到的元素和mark指针处的元素交换位置,遍历完成后把pivot的元素和mark指针元素交换位置,第一轮结束. 然后以同样的方法,分别遍历刚刚分割好的2部分.
>
> 实现方式: 递归或者栈

##### 堆排序

###### 实现思路

1.  把无序数组构建成二叉堆。需要从小到大排序，则构建成最大堆；需要从大到小排序，则构建成最小堆。
2. 循环删除堆顶元素，替换到二叉堆的末尾，调整堆产生新的堆顶。



###### 快排与堆排序对比

|                |   快排    |   堆排   |
| :------------: | :-------: | :------: |
| 平均时间复杂度 | O(nlogn)  | O(nlogn) |
| 最坏时间复杂度 | O(n  2  ) | O(nlogn) |
|   空间复杂度   |  O(logn)  |   O(1)   |
|     稳定性     |  不稳定   |  不稳定  |

##### 线性时间排序

##### 计数排序

###### 实现思路

以元素值为数组下标,以出现的次数为数组的元素.顺序遍历数组,没遍历一个元素则在与之对应的下标处的元素+1, 最后遍历新数组,按元素次数输出对应的下标.

它适用于一定范围内的整数排序。在取值范围不是很大的情况下，它的性
能甚至快过那些时间复杂度为O(nlogn)的排序。

##### 桶排序

###### 实现思路

1. 创建与数列等个数的桶;
2. 确定每个桶的区间,最后一个桶只包含数列最大值外，前面各个桶的区间按照比例来确定, 区间跨度 = （最大值-最小值）/ （桶的数量 - 1）
3. 对桶内部进行排序
4. 遍历所有桶并输出

##### 小结

![image-20210423102653611](https://raw.githubusercontent.com/tadpole145/images/main/image-20210423102653611.png)

#### 面试关键算法问题

##### 判断链表是否有环

双指针方法: 数学上的追及问题,保证2个指针速度不一致,只要有环就可以追上.

|            | 双层循环判断 | 采用hashMap记录 | 双指针方法 |
| :--------: | :----------: | :-------------: | :--------: |
| 时间复杂度 |    O(n^2)    |      O(n)       |    O(n)    |
| 空间复杂度 |     O(1)     |      O(n)       |    O(1)    |
|            |              |                 |            |

##### 如何求出环长

数学的追及问题, 第一次相遇后,继续前行,第二次相遇,统计出的步长=环长, 因为二指针的速度是1倍的关系,当速度慢的走一圈,速度快的恰好走了2圈了.

##### 如何求入环点

![image-20210425175232254](https://raw.githubusercontent.com/tadpole145/images/main/image-20210425175232254.png)

![image-20210425175355372](https://raw.githubusercontent.com/tadpole145/images/main/image-20210425175355372.png)

只要把其中一个指针放回到头节点位置，另一个指针保持在首次相遇点，两个指针都是每次向前走1步。那么，它们最终相遇的节点，就是入环节点。

##### 实现一个包含出栈（pop）、入栈（push）、取最小元素（getMin）3个方法时间复杂度为O(1)的栈.

思路: 创建2个栈,A为普通栈, B为辅助栈, 第一个元素,AB栈均入栈,第二个元素,A正常入栈,B则查看是否小于B的栈顶元素,＜则入栈,否则放弃, 当A出栈时,检查该元素是否是B中的最小,如果是则出栈,这样B一直存放的是A中的最小元素.

##### 求最大公约数

**欧几里得算法**: 两个正整数a和b（a>b），它们的最大公约数等于a除以b的余数c和b之间的最大公约数。如果C=0,则b为公约数,否则通过递归,不断求取余数,直到最后为1.此时对应的被除数即为最大公约数.  

**缺点**: 整数较大的时候,性能比较差

**更相减损术**: 两个正整数a和b（a>b），它们的最大公约数等于a-b的差值c和较小数b的最大公约数。如果c=0 ,那边b就为最大公约数,否则递归下去直到c=0

**缺点**:  运算次数比取模多

最优解法: 结合欧几里得算法与更相减损法,采用偶数位运算的方法.直到最后a=b.

- 当a和b均为偶数时，gcd(a,b) = 2×gcd(a/2, b/2) = 2×gcd(a>>1,b>>1)。
- 当a为偶数，b为奇数时，gcd(a,b) = gcd(a/2,b) = gcd(a>>1,b)。
- 当a为奇数，b为偶数时，gcd(a,b) = gcd(a,b/2) = gcd(a,b>>1)。
- 当a和b均为奇数时，先利用更相减损术运算一次，gcd(a,b)    =    gcd(b,a-
  b)，此时a-b必然是偶数，然后又可以继续进行移位运算。

如果(a&1)==0，则说明整数a是偶数；如果(a&1)!=0，则说明整数a是奇数.

##### 判断2的整数次幂

思路:  凡是2的整数次幂的数,其二进制都是最高位1,其余位0,如果将这个数-1, 其二进制数字全部变为1,这时候使用位与运算n&(n-1),结果必为0,否则不是2的整数幂.

##### 求无序数组的任意2个相邻元素的最大差值

- 通过计数排序的思想,求出原数组的最大值与最小值,然后计算区间并创立新数组,遍历原数组,把新数组对应下标的元素+1,遍历结束后, 遍历新数组,统计最大连续出现0值的次数,其下标差值即为最大相邻差.

  **缺点**: 当原数组元素最大最小值差距很大的时候,会大大增加其时间与空间复杂度

- 采用桶排序思想,创建与原数组等个数的桶,跨度为（max-min）/（n-1）。遍历后插入对应的桶中,记录桶的最大最小值.然后遍历所有的桶,统计每个桶的最大值与右侧非空桶的最小值的差,求取最大差值.

##### 如何使用栈实现队列

栈: 先入后出, 队列: 先入先出. 在学习数学时,一个数如果倒一次是倒数,倒2次就是自己本身了,同样道理,栈第一次是先入后出,再按出栈顺序添加到另外一个栈中,后入A栈的就变成先入B栈了,这样执行2次进栈,顺序就变成先进先出了.

##### 寻找全排列的下一个数

思路: 字典序算法; 

1. 从后向前查看逆序区域,找到逆序区域的前一位,就是数字置换的边界;
2. 让逆序区域的前一位和逆序区域中大于它的最小的数字交换位置;
3. 把原来的逆序区域额转为顺序状态;

##### 删去k个数字后的最小值

思路: 贪心算法

从左向右遍历，找到比自己右侧数字大的数字并删除; 如果没有找到要删除的数字，则删除最后一个数字, 然后清除整数左侧的数字0

优化:  采用出入栈的方式更节省时间与空间. 从前往后遍历,先入栈,然后比较当前栈与下一个数字的大小,如果逆序则栈顶出栈(代表删除),新数组入栈.重复出入栈K次即可

##### 如何实现大整数相加

把大整数拆成int 或者long类型范围内的数组,然后遍历数组相加减.参考BigDecimal底层实现的算法.

##### 如何求解金矿问题

思路: 动态规划, 确定全局最优解与最优子结构之间的关系,以及问题的边界.



